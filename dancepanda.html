<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancing Panda with Three.js and Matter.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- JavaScript libraries for 3D rendering and physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- SVGLoader is an add-on and must be included separately -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/SVGLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="./pandaPath.js"></script>
    <script>
        // --- Core Components ---
        let scene, camera, renderer;
        let engine, world, runner;
        let characterMesh;
        let physicsSkeleton;
        let vertexMapping = [];

        // --- Constants ---
        const PANDA_SCALE = 4; // Adjust this to change the size of the panda

        

        // --- Initialization ---
        init();
        animate();

        function init() {
            // 1. Setup Three.js Scene
            setupThreeJS();

            // FIX: Add the background loader back into the initialization sequence.
            const backgroundTextureLoader = new THREE.TextureLoader();
            backgroundTextureLoader.load(
                './dancepanda.png',
                (texture) => {
                    scene.background = texture;
                    console.log('Background texture loaded and set.');
                },
                undefined,
                (err) => {
                    console.error('Error loading background texture:', err);
                }
            );

            // 2. Setup Matter.js World
            setupMatterJS();
            
            // 3. Add mouse controls for interactivity
            addMouseControl();

            // 4. Create the visual mesh, which will then trigger physics setup
            createCharacterMesh(createPhysicsSkeleton, mapPhysicsToMesh);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera (Orthographic for 2D)
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2000; // This defines the visible area
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 1, 1000);
            camera.position.z = 500;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        function setupMatterJS() {
            // Engine
            engine = Matter.Engine.create();
            world = engine.world;
            world.gravity.y = 1; // A little bit of gravity to make it jiggle

            // Runner
            runner = Matter.Runner.create();
            Matter.Runner.run(runner, engine);

            // Add boundaries to the world
            const wallOptions = { isStatic: true };
            Matter.World.add(world, [
                Matter.Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 25, window.innerWidth, 50, wallOptions), // bottom
                Matter.Bodies.rectangle(window.innerWidth / 2, -25, window.innerWidth, 50, wallOptions), // top
                Matter.Bodies.rectangle(-25, window.innerHeight / 2, 50, window.innerHeight, wallOptions), // left
                Matter.Bodies.rectangle(window.innerWidth + 25, window.innerHeight / 2, 50, window.innerHeight, wallOptions) // right
            ]);
        }

        function createCharacterMesh(onMeshCreated, onMappingReady) {
            // The SVGLoader needs a full SVG XML string to parse.
            const fullSvgString = `
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
                    <path d="${svgPathData}" />
                </svg>
            `;
            
            const loader = new THREE.SVGLoader();
            const svgData = loader.parse(fullSvgString);
            const svgPath = svgData.paths[0];
            const shape = THREE.SVGLoader.createShapes(svgPath)[0];
            const geometry = new THREE.ShapeGeometry(shape);
            
            geometry.center();
            geometry.scale(PANDA_SCALE, -PANDA_SCALE, PANDA_SCALE);

            // --- FIX: Manually generate correct UV coordinates ---
            const uvAttribute = geometry.attributes.uv;
            const positionAttribute = geometry.attributes.position;
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;

            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                
                const u = (x - bbox.min.x) / (bbox.max.x - bbox.min.x);
                const v = (y - bbox.min.y) / (bbox.max.y - bbox.min.y);

                uvAttribute.setXY(i, u, v);
            }
            uvAttribute.needsUpdate = true;

            // Load the texture and create the mesh inside the callback
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                './dancepanda.png',

                // This function runs only AFTER the texture is loaded
                (texture) => {
                    console.log("Texture loaded successfully for mesh.");

                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });

                    characterMesh = new THREE.Mesh(geometry, material);
                    scene.add(characterMesh);

                    // --- CALLBACK CHAIN ---
                    // Now that the mesh exists, we can create the skeleton and map it.
                    onMeshCreated(onMappingReady);
                },
                undefined,
                (err) => { 
                    console.error('An error occurred loading the texture for the mesh:', err); 
                }
            );
        }

        function createPhysicsSkeleton(onSkeletonCreated) {
            physicsSkeleton = Matter.Composite.create();
            const bodyOptions = { frictionAir: 0.1, density: 0.1 };
            const constraintOptions = { stiffness: 0.06, damping: 0.1 };

            // Define the layout of the physics bodies to approximate the panda's shape
            const bodyPoints = [
                // Head
                [0, 150, 40], [ -50, 100, 30], [50, 100, 30], [0, 50, 45],
                // Body
                [0, -20, 60], [-70, -50, 50], [70, -50, 50], [0, -120, 60],
                // Arms
                [-150, 80, 30], [150, 80, 30],
                // Legs
                [-80, -220, 40], [80, -220, 40]
            ];

            const bodies = bodyPoints.map(p => 
                Matter.Bodies.circle(
                    window.innerWidth / 2 + p[0], 
                    window.innerHeight / 2 - p[1],
                    p[2], 
                    bodyOptions
                )
            );

            Matter.Composite.add(physicsSkeleton, bodies);

            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dist = Math.hypot(bodies[i].position.x - bodies[j].position.x, bodies[i].position.y - bodies[j].position.y);
                    if (dist < 200) {
                        const constraint = Matter.Constraint.create({ ...constraintOptions, bodyA: bodies[i], bodyB: bodies[j] });
                        Matter.Composite.add(physicsSkeleton, constraint);
                    }
                }
            }

            Matter.World.add(world, physicsSkeleton);
            console.log("Physics skeleton created.");
            // --- CALLBACK CHAIN ---
            onSkeletonCreated();
        }

        function mapPhysicsToMesh() {
            const physicsBodies = Matter.Composite.allBodies(physicsSkeleton);
            const positionAttribute = characterMesh.geometry.attributes.position;
            const originalPositions = []; // Store the initial vertex positions

            // For every vertex in the mesh...
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                originalPositions.push({ x, y });

                // Find the three closest physics bodies to this vertex
                const sortedBodies = physicsBodies.map(body => {
                    const bodyX = body.position.x - window.innerWidth / 2;
                    const bodyY = -(body.position.y - window.innerHeight / 2);
                    const distance = Math.hypot(x - bodyX, y - bodyY);
                    return { body, distance };
                }).sort((a, b) => a.distance - b.distance);

                const closestThree = sortedBodies.slice(0, 3);

                // Calculate the barycentric weights (influence)
                const totalDistance = closestThree.reduce((acc, val) => acc + val.distance, 0);
                const weights = closestThree.map(item => 1 - (item.distance / totalDistance));
                const totalWeight = weights.reduce((acc, val) => acc + val, 0);

                vertexMapping.push({
                    vertexIndex: i,
                    originalPos: { x, y },
                    influences: closestThree.map((item, index) => ({
                        body: item.body,
                        weight: weights[index] / totalWeight,
                        // --- FIX: Store the body's initial position at the time of mapping ---
                        initialBodyPos: {
                            x: item.body.position.x,
                            y: item.body.position.y
                        }
                    }))
                });
            }
            console.log(`Mapped influences for ${positionAttribute.count} vertices.`);
        }
        
        function addMouseControl() {
            const mouse = Matter.Mouse.create(renderer.domElement);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false
                    }
                }
            });

            Matter.World.add(world, mouseConstraint);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (characterMesh && vertexMapping.length > 0) {
                const positionAttribute = characterMesh.geometry.attributes.position;

                // Update each vertex based on the displacement of its influencing bodies
                vertexMapping.forEach(mapping => {
                    let totalDx = 0;
                    let totalDy = 0;

                    // Calculate the total weighted displacement from all influencing bodies
                    mapping.influences.forEach(influence => {
                        const body = influence.body;
                        const weight = influence.weight;
                        const initialPos = influence.initialBodyPos;

                        // Calculate the displacement (delta) for this one body in screen coordinates
                        const dx = body.position.x - initialPos.x;
                        const dy = body.position.y - initialPos.y;

                        // Add the weighted displacement to the total
                        totalDx += dx * weight;
                        totalDy += dy * weight;
                    });

                    // Apply the total displacement to the vertex's original position
                    // The 'totalDy' is negated to convert from Matter.js screen space (Y-down) to Three.js world space (Y-up)
                    positionAttribute.setX(mapping.vertexIndex, mapping.originalPos.x + totalDx);
                    positionAttribute.setY(mapping.vertexIndex, mapping.originalPos.y - totalDy);
                });

                positionAttribute.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2000;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
