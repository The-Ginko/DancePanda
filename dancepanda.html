<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancing Panda with Three.js and Matter.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- JavaScript libraries for 3D rendering and physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- SVGLoader is an add-on and must be included separately -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/SVGLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="./pandaPath.js"></script>
    <script>
        // --- Core Components ---
        let scene, camera, renderer;
        let engine, world, runner;
        let characterMesh;
        let physicsSkeleton;
        let vertexMapping = [];
        let pixelsPerThreeUnit; // NEW: To hold the correct conversion rate
        let helper;             // YELLOW DIAGNOSTIC BOX HELPER

        // --- Constants ---
        //const PANDA_SCALE = 2.25; // FIX: Drastically reduce the scale

        

        // --- Initialization ---
        init();
        animate();

        function init() {
            // 1. Setup Three.js Scene
            setupThreeJS();
            setupProportionalBackground();

            // 2. Setup Matter.js World
            setupMatterJS();
            
            // 3. Add mouse controls for interactivity
            addMouseControl();

            // 4. Create the visual mesh, which will then trigger physics setup
            createCharacterMesh(createPhysicsSkeleton, mapPhysicsToMesh);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera (Orthographic for 2D)
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2000; // This defines the visible area
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 1, 1000);
            camera.position.z = 500;
            
            // FIX: Calculate the true pixel-to-world-unit ratio
            pixelsPerThreeUnit = window.innerHeight / frustumSize;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        function setupMatterJS() {
            // Engine
            engine = Matter.Engine.create();
            world = engine.world;
            world.gravity.y = 0.23; // A little bit of gravity to make it jiggle

            // Runner
            runner = Matter.Runner.create();
            Matter.Runner.run(runner, engine);

            // Add boundaries to the world
            const wallOptions = { isStatic: true };
            Matter.World.add(world, [
                Matter.Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 25, window.innerWidth, 50, wallOptions), // bottom
                Matter.Bodies.rectangle(window.innerWidth / 2, -25, window.innerWidth, 50, wallOptions), // top
                Matter.Bodies.rectangle(-25, window.innerHeight / 2, 50, window.innerHeight, wallOptions), // left
                Matter.Bodies.rectangle(window.innerWidth + 25, window.innerHeight / 2, 50, window.innerHeight, wallOptions) // right
            ]);
        }

        function setupProportionalBackground() {
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('./dancepanda.png', (texture) => {
        const screenAspect = window.innerWidth / window.innerHeight;
        const imageAspect = texture.image.width / texture.image.height;

        // Create a plane geometry that fills the camera's view
        const frustumHeight = camera.top - camera.bottom;
        const frustumWidth = frustumHeight * screenAspect;
        const planeGeo = new THREE.PlaneGeometry(frustumWidth, frustumHeight);

        const planeMat = new THREE.MeshBasicMaterial({ map: texture });
        const backgroundPlane = new THREE.Mesh(planeGeo, planeMat);

        // Adjust texture repeat and offset to achieve "cover" effect
        if (screenAspect > imageAspect) {
            // Screen is wider than the image
            texture.repeat.set(1, imageAspect / screenAspect);
            texture.offset.set(0, (1 - imageAspect / screenAspect) / 2);
        } else {
            // Screen is taller than the image
            texture.repeat.set(screenAspect / imageAspect, 1);
            texture.offset.set((1 - screenAspect / imageAspect) / 2, 0);
        }
        
        // Place the plane behind everything else
        backgroundPlane.position.z = -100; 
        scene.add(backgroundPlane);
        console.log('Proportional background created.');
    });
}

        // NEW HELPER FUNCTION: Add this function above your createCharacterMesh function.
function normalizeSVGPath(pathData) {
    // This regular expression finds all the coordinate pairs in the path string.
    const regex = /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/g;
    const coords = pathData.match(regex).map(parseFloat);
    
    if (coords.length < 2) {
        return pathData; // Not enough data to process
    }

    // Separate the coordinates into x and y arrays.
    const xCoords = coords.filter((_, i) => i % 2 === 0);
    const yCoords = coords.filter((_, i) => i % 2 !== 0);

    // Find the bounding box of the path.
    const minX = Math.min(...xCoords);
    const maxX = Math.max(...xCoords);
    const minY = Math.min(...yCoords);
    const maxY = Math.max(...yCoords);

    // Calculate the center of the bounding box.
    const centerX = minX + (maxX - minX) / 2;
    const centerY = minY + (maxY - minY) / 2;

    // Create a new, corrected path string by translating every coordinate.
    let i = 0;
    const normalizedPath = pathData.replace(regex, () => {
        const originalCoord = coords[i];
        const isX = i % 2 === 0;
        const translatedCoord = isX ? (originalCoord - centerX) : (originalCoord - centerY);
        i++;
        return translatedCoord.toFixed(4); // Keep reasonable precision
    });

    return normalizedPath;
}


function createCharacterMesh(onMeshCreated, onMappingReady) {
    // Create the geometry from the SVG path data.
    const fullSvgString = `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
            <path d="${svgPathData}" />
        </svg>
    `;
    
    const loader = new THREE.SVGLoader();
    const svgData = loader.parse(fullSvgString);
    const svgPath = svgData.paths[0];
    const shape = THREE.SVGLoader.createShapes(svgPath)[0];
    const geometry = new THREE.ShapeGeometry(shape);

    // Center and scale the geometry to the desired size in the scene.
    geometry.center();
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox;
    const geomHeight = bbox.max.y - bbox.min.y;
    const targetHeight = 1800; // Adjust for final size
    const scale = targetHeight / geomHeight;
    geometry.scale(scale, -scale, scale);
    geometry.computeBoundingBox();

    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(
        './dancepanda_char.png',
        (texture) => {
            const finalBbox = geometry.boundingBox;
            const geomWidth = finalBbox.max.x - finalBbox.min.x;
            const geomHeight = finalBbox.max.y - finalBbox.min.y;
            const geomAspect = geomWidth / geomHeight;
            const imageAspect = texture.image.width / texture.image.height;

            const uvAttribute = geometry.attributes.uv;
            const positionAttribute = geometry.attributes.position;

            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                
                // Calculate the base UVs.
                let u = (x - finalBbox.min.x) / geomWidth;
                let v = (y - finalBbox.min.y) / geomHeight;
                
                // --- START: CORRECTED ASPECT RATIO MAPPING ---
                // This logic correctly scales the UVs to fit the geometry
                // without leaving margins or causing distortion.
                if (geomAspect > imageAspect) {
                    texture.matrix.setUvTransform(0, 0, imageAspect / geomAspect, 1, 0, 0.5, 0.5);
                } else {
                    texture.matrix.setUvTransform(0, 0, 1, geomAspect / imageAspect, 0, 0.5, 0.5);
                }
                // --- END: CORRECTED ASPECT RATIO MAPPING ---

                uvAttribute.setXY(i, u, v);
            }
            uvAttribute.needsUpdate = true;


            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            characterMesh = new THREE.Mesh(geometry, material);
            scene.add(characterMesh);

            onMeshCreated(onMappingReady);
        },
        undefined,
        (err) => { 
            console.error('An error occurred loading the texture for the mesh:', err); 
        }
    );
}

        function createPhysicsSkeleton(onSkeletonCreated) {
            physicsSkeleton = Matter.Composite.create();
            const bodyOptions = { frictionAir: 0.1, density: 0.1 };
            const constraintOptions = { stiffness: 0.06, damping: 0.1 };

            // Define the layout of the physics bodies to approximate the panda's shape
            const bodyPoints = [
                // Head
                [0, 150, 40], [ -50, 100, 30], [50, 100, 30], [0, 50, 45],
                // Body
                [0, -20, 60], [-70, -50, 50], [70, -50, 50], [0, -120, 60],
                // Arms
                [-150, 80, 30], [150, 80, 30],
                // Legs
                [-80, -220, 40], [80, -220, 40]
            ];

            const bodies = bodyPoints.map(p => 
                Matter.Bodies.circle(
                    window.innerWidth / 2 + p[0], 
                    window.innerHeight / 2 + p[1], // --- FIX: Use standard coordinates ---
                    p[2], 
                    bodyOptions
                )
            );

            Matter.Composite.add(physicsSkeleton, bodies);

            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dist = Math.hypot(bodies[i].position.x - bodies[j].position.x, bodies[i].position.y - bodies[j].position.y);
                    if (dist < 200) {
                        const constraint = Matter.Constraint.create({ ...constraintOptions, bodyA: bodies[i], bodyB: bodies[j] });
                        Matter.Composite.add(physicsSkeleton, constraint);
                    }
                }
            }

            Matter.World.add(world, physicsSkeleton);
            console.log("Physics skeleton created.");
            // --- CALLBACK CHAIN ---
            onSkeletonCreated();
        }

        function mapPhysicsToMesh() {
            const physicsBodies = Matter.Composite.allBodies(physicsSkeleton);
            const positionAttribute = characterMesh.geometry.attributes.position;
            const originalPositions = []; // Store the initial vertex positions

            // For every vertex in the mesh...
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                originalPositions.push({ x, y });

                // Find the three closest physics bodies to this vertex
                const sortedBodies = physicsBodies.map(body => {
                    // --- FIX: Convert body's pixel position to Three.js units correctly ---
                    const bodyX = (body.position.x - window.innerWidth / 2) / pixelsPerThreeUnit;
                    const bodyY = -(body.position.y - window.innerHeight / 2) / pixelsPerThreeUnit;
                    
                    const distance = Math.hypot(x - bodyX, y - bodyY);
                    return { body, distance };
                }).sort((a, b) => a.distance - b.distance);

                const closestThree = sortedBodies.slice(0, 3);

                // Calculate the barycentric weights (influence)
                const totalDistance = closestThree.reduce((acc, val) => acc + val.distance, 0);
                const weights = closestThree.map(item => 1 - (item.distance / totalDistance));
                const totalWeight = weights.reduce((acc, val) => acc + val, 0);

                vertexMapping.push({
                    vertexIndex: i,
                    originalPos: { x, y },
                    influences: closestThree.map((item, index) => ({
                        body: item.body,
                        weight: weights[index] / totalWeight,
                        // --- FIX: Store the body's initial position at the time of mapping ---
                        initialBodyPos: {
                            x: item.body.position.x,
                            y: item.body.position.y
                        }
                    }))
                });
            }
            console.log(`Mapped influences for ${positionAttribute.count} vertices.`);
        }
        
        function addMouseControl() {
            const mouse = Matter.Mouse.create(renderer.domElement);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false
                    }
                }
            });

            Matter.World.add(world, mouseConstraint);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // --- YELLOW DIAGNOSTIC BLOCK HELPER ---
    if (helper) {
        helper.update();
    }

            if (characterMesh && vertexMapping.length > 0) {
                const positionAttribute = characterMesh.geometry.attributes.position;

                // Update each vertex based on the displacement of its influencing bodies
                vertexMapping.forEach(mapping => {
                    let totalDx = 0;
                    let totalDy = 0;

                    // Calculate the total weighted displacement from all influencing bodies
                    mapping.influences.forEach(influence => {
                        const body = influence.body;
                        const weight = influence.weight;
                        const initialPos = influence.initialBodyPos;

                        // Calculate the displacement (delta) for this one body in screen coordinates
                        const dx = body.position.x - initialPos.x;
                        const dy = body.position.y - initialPos.y;

                        // Add the weighted displacement to the total
                        totalDx += dx * weight;
                        totalDy += dy * weight;
                    });

                    // --- FIX: Convert displacement from pixels to Three.js units correctly ---
                    const displacementX = totalDx / pixelsPerThreeUnit;
                    const displacementY = totalDy / pixelsPerThreeUnit;

                    // Apply the correctly scaled displacement to the vertex's original position
                    // The 'displacementY' is negated to convert from Matter.js screen space (Y-down) to Three.js world space (Y-up)
                    positionAttribute.setX(mapping.vertexIndex, mapping.originalPos.x + displacementX);
                    positionAttribute.setY(mapping.vertexIndex, mapping.originalPos.y - displacementY);
                });

                positionAttribute.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2000;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Recalculate the conversion factor on resize
            pixelsPerThreeUnit = window.innerHeight / frustumSize;
        }
    </script>
</body>
</html>
