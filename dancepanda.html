<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancing Panda with Three.js and Matter.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- JavaScript libraries for 3D rendering and physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- SVGLoader is an add-on and must be included separately -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/SVGLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="./pandaPath.js"></script>
    <script>
        // --- Core Components ---
        let scene, camera, renderer;
        let engine, world, runner;
        let characterMesh;
        let physicsSkeleton;
        let vertexMapping = [];
        let pixelsPerThreeUnit; // NEW: To hold the correct conversion rate
        let helper;             // YELLOW DIAGNOSTIC BOX HELPER

        // --- Constants ---
        //const PANDA_SCALE = 2.25; // FIX: Drastically reduce the scale

        

        // --- Initialization ---
        init();
        animate();

        function init() {
            // 1. Setup Three.js Scene
            setupThreeJS();
            setupProportionalBackground();

            // 2. Setup Matter.js World
            setupMatterJS();
            
            // 3. Add mouse controls for interactivity
            addMouseControl();

            // 4. Create the visual mesh, which will then trigger physics setup
            createCharacterMesh(createPhysicsSkeleton, mapPhysicsToMesh);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera (Orthographic for 2D)
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2000; // This defines the visible area
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 1, 1000);
            camera.position.z = 500;
            
            // FIX: Calculate the true pixel-to-world-unit ratio
            pixelsPerThreeUnit = window.innerHeight / frustumSize;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        function setupMatterJS() {
            // Engine
            engine = Matter.Engine.create();
            world = engine.world;
            world.gravity.y = 1; // A little bit of gravity to make it jiggle

            // Runner
            runner = Matter.Runner.create();
            Matter.Runner.run(runner, engine);

            // Add boundaries to the world
            const wallOptions = { isStatic: true };
            Matter.World.add(world, [
                Matter.Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 25, window.innerWidth, 50, wallOptions), // bottom
                Matter.Bodies.rectangle(window.innerWidth / 2, -25, window.innerWidth, 50, wallOptions), // top
                Matter.Bodies.rectangle(-25, window.innerHeight / 2, 50, window.innerHeight, wallOptions), // left
                Matter.Bodies.rectangle(window.innerWidth + 25, window.innerHeight / 2, 50, window.innerHeight, wallOptions) // right
            ]);
        }

        function setupProportionalBackground() {
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('./dancepanda.png', (texture) => {
        const screenAspect = window.innerWidth / window.innerHeight;
        const imageAspect = texture.image.width / texture.image.height;

        // Create a plane geometry that fills the camera's view
        const frustumHeight = camera.top - camera.bottom;
        const frustumWidth = frustumHeight * screenAspect;
        const planeGeo = new THREE.PlaneGeometry(frustumWidth, frustumHeight);

        const planeMat = new THREE.MeshBasicMaterial({ map: texture });
        const backgroundPlane = new THREE.Mesh(planeGeo, planeMat);

        // Adjust texture repeat and offset to achieve "cover" effect
        if (screenAspect > imageAspect) {
            // Screen is wider than the image
            texture.repeat.set(1, imageAspect / screenAspect);
            texture.offset.set(0, (1 - imageAspect / screenAspect) / 2);
        } else {
            // Screen is taller than the image
            texture.repeat.set(screenAspect / imageAspect, 1);
            texture.offset.set((1 - screenAspect / imageAspect) / 2, 0);
        }
        
        // Place the plane behind everything else
        backgroundPlane.position.z = -100; 
        scene.add(backgroundPlane);
        console.log('Proportional background created.');
    });
}

function createCharacterMesh(onMeshCreated, onMappingReady) {
    // The SVGLoader needs a full SVG XML string to parse.
    const fullSvgString = `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg">
            <path d="${svgPathData}" />
        </svg>
    `;
    
    const loader = new THREE.SVGLoader();
    const svgData = loader.parse(fullSvgString);
    const svgPath = svgData.paths[0];
    const shape = THREE.SVGLoader.createShapes(svgPath)[0];
    const geometry = new THREE.ShapeGeometry(shape);
    
    // --- FIX START: DYNAMICALLY SCALE GEOMETRY TO MATCH TEXTURE ASPECT RATIO ---

    // 1. Center the geometry first. This is important for uniform scaling.
    geometry.center();

    // 2. Compute the initial bounding box to get the SVG's intrinsic size.
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox;
    const geometryWidth = bbox.max.x - bbox.min.x;
    const geometryHeight = bbox.max.y - bbox.min.y;

    // 3. Define the target size. This should match your texture's dimensions.
    const targetWidth = 2048;
    const targetHeight = 2048;

    // 4. Calculate the correct scale factor.
    //    We'll scale based on height and let width adjust proportionally.
    const scale = targetHeight / geometryHeight;

    // 5. Apply the calculated scale. Note the negative Y to flip the SVG.
    geometry.scale(scale, -scale, scale);

    // --- FIX END ---


    // --- FIX: Manually generate correct UV coordinates ---
    // This part is now done AFTER the geometry is correctly scaled.
    const uvAttribute = geometry.attributes.uv;
    const positionAttribute = geometry.attributes.position;
    geometry.computeBoundingBox(); // Re-compute the bounding box for the scaled geometry
    const scaledBbox = geometry.boundingBox;

    for (let i = 0; i < positionAttribute.count; i++) {
        const x = positionAttribute.getX(i);
        const y = positionAttribute.getY(i);
        
        const u = (x - scaledBbox.min.x) / (scaledBbox.max.x - scaledBbox.min.x);
        const v = (y - scaledBbox.min.y) / (scaledBbox.max.y - scaledBbox.min.y);

        uvAttribute.setXY(i, u, v);
    }
    uvAttribute.needsUpdate = true;

    // Load the texture and create the mesh inside the callback
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(
        './dancepanda.png',

        // This function runs only AFTER the texture is loaded
        (texture) => {
            console.log("Texture loaded successfully for mesh.");

            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            characterMesh = new THREE.Mesh(geometry, material);
            scene.add(characterMesh);
            // --- YELLOW DIAGNOSTIC BOX ---
            helper = new THREE.BoxHelper( characterMesh, 0xffff00 ); // Creates a yellow box
            scene.add( helper );

            // --- CALLBACK CHAIN ---
            // Now that the mesh exists, we can create the skeleton and map it.
            onMeshCreated(onMappingReady);
        },
        undefined,
        (err) => { 
            console.error('An error occurred loading the texture for the mesh:', err); 
        }
    );
}

        function createPhysicsSkeleton(onSkeletonCreated) {
            physicsSkeleton = Matter.Composite.create();
            const bodyOptions = { frictionAir: 0.1, density: 0.1 };
            const constraintOptions = { stiffness: 0.06, damping: 0.1 };

            // Define the layout of the physics bodies to approximate the panda's shape
            const bodyPoints = [
                // Head
                [0, 150, 40], [ -50, 100, 30], [50, 100, 30], [0, 50, 45],
                // Body
                [0, -20, 60], [-70, -50, 50], [70, -50, 50], [0, -120, 60],
                // Arms
                [-150, 80, 30], [150, 80, 30],
                // Legs
                [-80, -220, 40], [80, -220, 40]
            ];

            const bodies = bodyPoints.map(p => 
                Matter.Bodies.circle(
                    window.innerWidth / 2 + p[0], 
                    window.innerHeight / 2 + p[1], // --- FIX: Use standard coordinates ---
                    p[2], 
                    bodyOptions
                )
            );

            Matter.Composite.add(physicsSkeleton, bodies);

            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dist = Math.hypot(bodies[i].position.x - bodies[j].position.x, bodies[i].position.y - bodies[j].position.y);
                    if (dist < 200) {
                        const constraint = Matter.Constraint.create({ ...constraintOptions, bodyA: bodies[i], bodyB: bodies[j] });
                        Matter.Composite.add(physicsSkeleton, constraint);
                    }
                }
            }

            Matter.World.add(world, physicsSkeleton);
            console.log("Physics skeleton created.");
            // --- CALLBACK CHAIN ---
            onSkeletonCreated();
        }

        function mapPhysicsToMesh() {
            const physicsBodies = Matter.Composite.allBodies(physicsSkeleton);
            const positionAttribute = characterMesh.geometry.attributes.position;
            const originalPositions = []; // Store the initial vertex positions

            // For every vertex in the mesh...
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                originalPositions.push({ x, y });

                // Find the three closest physics bodies to this vertex
                const sortedBodies = physicsBodies.map(body => {
                    // --- FIX: Convert body's pixel position to Three.js units correctly ---
                    const bodyX = (body.position.x - window.innerWidth / 2) / pixelsPerThreeUnit;
                    const bodyY = -(body.position.y - window.innerHeight / 2) / pixelsPerThreeUnit;
                    
                    const distance = Math.hypot(x - bodyX, y - bodyY);
                    return { body, distance };
                }).sort((a, b) => a.distance - b.distance);

                const closestThree = sortedBodies.slice(0, 3);

                // Calculate the barycentric weights (influence)
                const totalDistance = closestThree.reduce((acc, val) => acc + val.distance, 0);
                const weights = closestThree.map(item => 1 - (item.distance / totalDistance));
                const totalWeight = weights.reduce((acc, val) => acc + val, 0);

                vertexMapping.push({
                    vertexIndex: i,
                    originalPos: { x, y },
                    influences: closestThree.map((item, index) => ({
                        body: item.body,
                        weight: weights[index] / totalWeight,
                        // --- FIX: Store the body's initial position at the time of mapping ---
                        initialBodyPos: {
                            x: item.body.position.x,
                            y: item.body.position.y
                        }
                    }))
                });
            }
            console.log(`Mapped influences for ${positionAttribute.count} vertices.`);
        }
        
        function addMouseControl() {
            const mouse = Matter.Mouse.create(renderer.domElement);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false
                    }
                }
            });

            Matter.World.add(world, mouseConstraint);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // --- YELLOW DIAGNOSTIC BLOCK HELPER ---
    if (helper) {
        helper.update();
    }

            if (characterMesh && vertexMapping.length > 0) {
                const positionAttribute = characterMesh.geometry.attributes.position;

                // Update each vertex based on the displacement of its influencing bodies
                vertexMapping.forEach(mapping => {
                    let totalDx = 0;
                    let totalDy = 0;

                    // Calculate the total weighted displacement from all influencing bodies
                    mapping.influences.forEach(influence => {
                        const body = influence.body;
                        const weight = influence.weight;
                        const initialPos = influence.initialBodyPos;

                        // Calculate the displacement (delta) for this one body in screen coordinates
                        const dx = body.position.x - initialPos.x;
                        const dy = body.position.y - initialPos.y;

                        // Add the weighted displacement to the total
                        totalDx += dx * weight;
                        totalDy += dy * weight;
                    });

                    // --- FIX: Convert displacement from pixels to Three.js units correctly ---
                    const displacementX = totalDx / pixelsPerThreeUnit;66666666
                    const displacementY = totalDy / pixelsPerThreeUnit;

                    // Apply the correctly scaled displacement to the vertex's original position
                    // The 'displacementY' is negated to convert from Matter.js screen space (Y-down) to Three.js world space (Y-up)
                    positionAttribute.setX(mapping.vertexIndex, mapping.originalPos.x + displacementX);
                    positionAttribute.setY(mapping.vertexIndex, mapping.originalPos.y - displacementY);
                });

                positionAttribute.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2000;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Recalculate the conversion factor on resize
            pixelsPerThreeUnit = window.innerHeight / frustumSize;
        }
    </script>
</body>
</html>
